---
layout: post
title: poj1785
category: chinese
---
<p>1.理解了rmq的st算法。就是将每个大区间用刚好大于其长度一半的2^x的大小来将其分割为两个有重叠区间求解。即s~t被分为s~s + 2^x 和 t - 2^x + 1 ~t。吉大的第一个st是错误的。</p>
<p>2.学会了笛卡尔树，即一个满足堆的大小性质的二叉搜索树，但不一定是完全二叉树。这是将rmq转为lca的关键。</p>
<p>3.scanf的用法，%*[ ],表示越过[ ]中的字符，%[a-z]表示读入字符串，直到遇到不是a-z中的字符为止。%[^a]表示读入字符串直到遇到字符a为止，但a并没有被读入。</p>
<p>题意：给出一些节点，每个节点有两个值，lable和priority（都是唯一的），要求构成一个笛卡尔树，按lable是二叉排序树，按priority是大根堆（不一定完全二叉树）。输出括号表示。</p>
<p>分析：先把节点按lable排序，从小到大依次插入，这样每次插入的节点就要插到排序二叉树的最右边，首先要沿着右儿子找到最右边的节点（再无右儿子），然后分两种情况，最右节点的priority和当前插入节点的priority比较，若大于则直接将当前插入节点接到其右子树。否则让当前插入节点取代最右节点位置并将原最右节点及其子树接到当前插入节点的左子树。</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('f64eef43-33be-4c6b-bd6f-d5f8a9f5ec8d')"><img id="code_img_closed_f64eef43-33be-4c6b-bd6f-d5f8a9f5ec8d" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_f64eef43-33be-4c6b-bd6f-d5f8a9f5ec8d" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('f64eef43-33be-4c6b-bd6f-d5f8a9f5ec8d',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" /><span class="cnblogs_code_collapse">View Code </span>
<div id="cnblogs_code_open_f64eef43-33be-4c6b-bd6f-d5f8a9f5ec8d" class="cnblogs_code_hide">
<div><span style="color: #000000;">#include </span><span style="color: #000000;">&lt;</span><span style="color: #000000;">iostream</span><span style="color: #000000;">&gt;</span><span style="color: #000000;"><br />#include </span><span style="color: #000000;">&lt;</span><span style="color: #000000;">cstdio</span><span style="color: #000000;">&gt;</span><span style="color: #000000;"><br />#include </span><span style="color: #000000;">&lt;</span><span style="color: #000000;">cstdlib</span><span style="color: #000000;">&gt;</span><span style="color: #000000;"><br />#include </span><span style="color: #000000;">&lt;</span><span style="color: #000000;">cstring</span><span style="color: #000000;">&gt;</span><span style="color: #000000;"><br />#include </span><span style="color: #000000;">&lt;</span><span style="color: #000000;">algorithm</span><span style="color: #000000;">&gt;</span><span style="color: #000000;"><br /></span><span style="color: #0000ff;">using</span><span style="color: #0000ff;">namespace</span><span style="color: #000000;"> std;<br /><br /></span><span style="color: #0000ff;">#define</span><span style="color: #000000;"> maxn 100005</span><span style="color: #000000;"><br /><br /></span><span style="color: #0000ff;">struct</span><span style="color: #000000;"> Node<br />{<br />    </span><span style="color: #0000ff;">char</span><span style="color: #000000;"> c[</span><span style="color: #800080;">100</span><span style="color: #000000;">];<br />    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> v;<br />    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> l, r, fa;<br />} tree[maxn];<br /><br /></span><span style="color: #0000ff;">int</span><span style="color: #000000;"> n;<br /><br /></span><span style="color: #0000ff;">bool</span><span style="color: #0000ff;">operator</span><span style="color: #000000;">&lt;</span><span style="color: #000000;">(</span><span style="color: #0000ff;">const</span><span style="color: #000000;"> Node </span><span style="color: #000000;">&amp;</span><span style="color: #000000;">a, </span><span style="color: #0000ff;">const</span><span style="color: #000000;"> Node </span><span style="color: #000000;">&amp;</span><span style="color: #000000;">b)<br />{<br />    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> strcmp(a.c, b.c) </span><span style="color: #000000;">&lt;</span><span style="color: #800080;">0</span><span style="color: #000000;">;<br />}<br /><br /></span><span style="color: #0000ff;">void</span><span style="color: #000000;"> input()<br />{<br />    </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> i </span><span style="color: #000000;">=</span><span style="color: #800080;">1</span><span style="color: #000000;">; i </span><span style="color: #000000;">&lt;=</span><span style="color: #000000;"> n; i</span><span style="color: #000000;">++</span><span style="color: #000000;">)<br />        scanf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%*[ ]%[^/]/%d</span><span style="color: #800000;">"</span><span style="color: #000000;">, tree[i].c, </span><span style="color: #000000;">&amp;</span><span style="color: #000000;">tree[i].v);<br />}<br /><br /></span><span style="color: #0000ff;">void</span><span style="color: #000000;"> ins(</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> i)<br />{<br />    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> j </span><span style="color: #000000;">=</span><span style="color: #000000;"> i </span><span style="color: #000000;">-</span><span style="color: #800080;">1</span><span style="color: #000000;">;<br /><br />    </span><span style="color: #0000ff;">while</span><span style="color: #000000;"> (tree[j].v </span><span style="color: #000000;">&lt;</span><span style="color: #000000;"> tree[i].v)<br />        j </span><span style="color: #000000;">=</span><span style="color: #000000;"> tree[j].fa;<br />    tree[i].l </span><span style="color: #000000;">=</span><span style="color: #000000;"> tree[j].r;<br />    tree[tree[i].l].fa </span><span style="color: #000000;">=</span><span style="color: #000000;"> i;<br />    tree[j].r </span><span style="color: #000000;">=</span><span style="color: #000000;"> i;<br />    tree[i].fa </span><span style="color: #000000;">=</span><span style="color: #000000;"> j;<br />}<br /><br /></span><span style="color: #0000ff;">void</span><span style="color: #000000;"> dfs(</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> i)<br />{<br />    </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (</span><span style="color: #000000;">!</span><span style="color: #000000;">i)<br />        </span><span style="color: #0000ff;">return</span><span style="color: #000000;">;<br />    printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">(</span><span style="color: #800000;">"</span><span style="color: #000000;">);<br />    dfs(tree[i].l);<br />    printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%s/%d</span><span style="color: #800000;">"</span><span style="color: #000000;">, tree[i].c, tree[i].v);<br />    dfs(tree[i].r);<br />    printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">)</span><span style="color: #800000;">"</span><span style="color: #000000;">);<br />}<br /><br /></span><span style="color: #0000ff;">int</span><span style="color: #000000;"> main()<br />{<br />    </span><span style="color: #008000;">//</span><span style="color: #008000;">freopen("t.txt", "r", stdin);</span><span style="color: #008000;"><br /></span><span style="color: #0000ff;">while</span><span style="color: #000000;"> (scanf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d</span><span style="color: #800000;">"</span><span style="color: #000000;">, </span><span style="color: #000000;">&amp;</span><span style="color: #000000;">n), n)<br />    {<br />        input();<br />        tree[</span><span style="color: #800080;">0</span><span style="color: #000000;">].l </span><span style="color: #000000;">=</span><span style="color: #000000;"> tree[</span><span style="color: #800080;">0</span><span style="color: #000000;">].r </span><span style="color: #000000;">=</span><span style="color: #000000;"> tree[</span><span style="color: #800080;">0</span><span style="color: #000000;">].fa </span><span style="color: #000000;">=</span><span style="color: #800080;">0</span><span style="color: #000000;">;<br />        tree[</span><span style="color: #800080;">0</span><span style="color: #000000;">].v </span><span style="color: #000000;">=</span><span style="color: #800080;">0x3f3f3f3f</span><span style="color: #000000;">;<br />        sort(tree </span><span style="color: #000000;">+</span><span style="color: #800080;">1</span><span style="color: #000000;">, tree </span><span style="color: #000000;">+</span><span style="color: #000000;"> n </span><span style="color: #000000;">+</span><span style="color: #800080;">1</span><span style="color: #000000;">);<br />        </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> i </span><span style="color: #000000;">=</span><span style="color: #800080;">1</span><span style="color: #000000;">; i </span><span style="color: #000000;">&lt;=</span><span style="color: #000000;"> n; i</span><span style="color: #000000;">++</span><span style="color: #000000;">)<br />        {<br />            tree[i].l </span><span style="color: #000000;">=</span><span style="color: #000000;"> tree[i].r </span><span style="color: #000000;">=</span><span style="color: #000000;"> tree[i].fa </span><span style="color: #000000;">=</span><span style="color: #800080;">0</span><span style="color: #000000;">;<br />            ins(i);<br />        }<br />        dfs(tree[</span><span style="color: #800080;">0</span><span style="color: #000000;">].r);<br />        printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">\n</span><span style="color: #800000;">"</span><span style="color: #000000;">);<br />    }<br />    </span><span style="color: #0000ff;">return</span><span style="color: #800080;">0</span><span style="color: #000000;">;<br />}</span></div>

</div>

</div>
