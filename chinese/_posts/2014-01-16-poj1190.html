---
layout: post
title: poj1190
category: chinese
---
<p>题意：一个由多个圆柱体摞起来形成的蛋糕，要求上边的圆柱的半径和高都比下边的圆柱大。给定圆柱的体积，问除去下表面之外的圆柱面积最小是多少？</p>
<p>分析：深度优先搜索。由最底层的蛋糕向上逐层搜索，每次迭代则蛋糕向上一层。所以搜索深度确定，为蛋糕的层数。</p>
<p>与通常的深度优先搜索不同的是，本题的每个搜索状态由两个量来标明：半径和高。因此向下一个状态迭代时需要用一个二重循环来枚举接下来状态的半径和高。</p>
<p>可见状态空间极大。需要三个剪枝方可通过本题。</p>
<p>我们首先要了解，位于蛋糕顶端的x层的最小体积是：1^3+2^3+3^3+...+x^3</p>
<p>最小面积是：2*(1^2+2^2+3^2+...+x^2)</p>
<p>即从顶层向下半径依次取1～x，高依次取1～x。</p>
<p>三个剪枝是：</p>
<p>1.总体积减去蛋糕当前层以下的层的总体积是否小于上面的层所能构成的最小体积。如果小于则返回。</p>
<p>2.已算得的答案（最小面积）减去蛋糕当前层以下的层的总面积是否小于上面的层所能构成的最小面积。如果小于则返回。</p>
<p>3.设剩余总体积为总体积减去蛋糕下面的层的总体积，剩余总面积是当前已得最优解减去蛋糕当前层以下的层的总面积。设ri为每层的半径，hi为每层的高度。蛋糕上面层的总面积是对2*ri*hi求和。总体积ri*ri*hi求和。剩余总体积*2再除以当前层的半径必须小于剩余总面积，否则返回。（2&times;sigma(ri*ri*hi)/rk &gt; sigma(2*ri*hi) i=1~k)之所以左边大于右边是因为rk&gt;ri &nbsp;对于i&lt;k。</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('8a46702c-b310-4cc2-bd47-3b92a27555a0')"><img id="code_img_closed_8a46702c-b310-4cc2-bd47-3b92a27555a0" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_8a46702c-b310-4cc2-bd47-3b92a27555a0" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('8a46702c-b310-4cc2-bd47-3b92a27555a0',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_8a46702c-b310-4cc2-bd47-3b92a27555a0" class="cnblogs_code_hide">
<pre>#include &lt;cstdio&gt;<span style="color: #000000;">
#include </span>&lt;algorithm&gt;<span style="color: #000000;">
#include </span>&lt;cmath&gt;
<span style="color: #0000ff;">using</span> <span style="color: #0000ff;">namespace</span><span style="color: #000000;"> std;

</span><span style="color: #0000ff;">#define</span> MAX_LAYER_NUM 25
<span style="color: #0000ff;">#define</span> INF 0x3f3f3f3f

<span style="color: #0000ff;">int</span><span style="color: #000000;"> layer_num;
</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> total_volume;
</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> min_vol[MAX_LAYER_NUM];
</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> min_area[MAX_LAYER_NUM];
</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> ans;

</span><span style="color: #0000ff;">void</span><span style="color: #000000;"> init()
{
    min_area[</span><span style="color: #800080;">0</span>] = min_vol[<span style="color: #800080;">0</span>] = <span style="color: #800080;">0</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">1</span>; i &lt;= <span style="color: #800080;">20</span>; i++<span style="color: #000000;">)
    {
        min_vol[i] </span>= min_vol[i - <span style="color: #800080;">1</span>] + i * i *<span style="color: #000000;"> i;
        min_area[i] </span>= min_area[i - <span style="color: #800080;">1</span>] + <span style="color: #800080;">2</span> * i *<span style="color: #000000;"> i;
    }
}

</span><span style="color: #0000ff;">void</span> DFS(<span style="color: #0000ff;">int</span> r_limit, <span style="color: #0000ff;">int</span> h_limit, <span style="color: #0000ff;">int</span> layer, <span style="color: #0000ff;">int</span> area, <span style="color: #0000ff;">int</span><span style="color: #000000;"> volume)
{
    </span><span style="color: #0000ff;">if</span> (layer == <span style="color: #800080;">0</span><span style="color: #000000;">)
    {
        </span><span style="color: #0000ff;">if</span> (volume !=<span style="color: #000000;"> total_volume)
            </span><span style="color: #0000ff;">return</span><span style="color: #000000;">;
        ans </span>=<span style="color: #000000;"> min(ans, area);
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;">;
    }
    </span><span style="color: #0000ff;">if</span> (total_volume - volume &lt;<span style="color: #000000;"> min_vol[layer])
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">if</span> (ans - area &lt;<span style="color: #000000;"> min_area[layer])
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">if</span> (layer &lt; layer_num &amp;&amp; area + <span style="color: #800080;">2</span> * (total_volume - volume) / r_limit &gt;<span style="color: #000000;"> ans)
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = r_limit; i &gt;= layer; i--<span style="color: #000000;">)
    {
        </span><span style="color: #0000ff;">if</span> (layer ==<span style="color: #000000;"> layer_num)
        {
            area </span>= i *<span style="color: #000000;"> i;
        }
        </span><span style="color: #0000ff;">int</span> max_h = (total_volume - min_vol[layer - <span style="color: #800080;">1</span>] - volume) / (i *<span style="color: #000000;"> i);
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = min(max_h, h_limit); j &gt;= layer; j--<span style="color: #000000;">)
        {
            DFS(i </span>- <span style="color: #800080;">1</span>, j - <span style="color: #800080;">1</span>, layer - <span style="color: #800080;">1</span>, area + <span style="color: #800080;">2</span> * i * j, volume + i * i *<span style="color: #000000;"> j);
        }
    }
}

</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> main()
{
    scanf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d%d</span><span style="color: #800000;">"</span>, &amp;total_volume, &amp;<span style="color: #000000;">layer_num);
    ans </span>=<span style="color: #000000;"> INF;
    init();
    DFS((</span><span style="color: #0000ff;">int</span>)sqrt(total_volume), total_volume, layer_num, <span style="color: #800080;">0</span>, <span style="color: #800080;">0</span><span style="color: #000000;">);
    printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d\n</span><span style="color: #800000;">"</span><span style="color: #000000;">, ans);
    </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
}</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code </span></div>
<p>&nbsp;</p>
