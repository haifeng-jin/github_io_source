---
layout: post
title: poj2887
category: chinese
---
<p>线段树</p>
<p>这种每次在第几个位置插入元素的题，都可以用线段树，从最后一次插入开始来查找每次插入的元素的最终位置。</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('fc8e29f7-6f84-42da-bf20-33672675e178')"><img id="code_img_closed_fc8e29f7-6f84-42da-bf20-33672675e178" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" /><img style="display: none;" id="code_img_opened_fc8e29f7-6f84-42da-bf20-33672675e178" class="code_img_opened" onclick="cnblogs_code_hide('fc8e29f7-6f84-42da-bf20-33672675e178',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" /><span class="cnblogs_code_collapse">View Code </span>
<div id="cnblogs_code_open_fc8e29f7-6f84-42da-bf20-33672675e178" class="cnblogs_code_hide">
<pre>#include &lt;iostream&gt;<br />#include &lt;cstdlib&gt;<br />#include &lt;cstring&gt;<br />#include &lt;cstdio&gt;<br /><span style="color: #0000ff;">using</span> <span style="color: #0000ff;">namespace</span> std;<br /><br /><span style="color: #0000ff;">#define</span> maxl 2000005<br /><span style="color: #0000ff;">#define</span> maxn 2005<br /><br /><span style="color: #0000ff;">struct</span> Elem<br />{<br />    <span style="color: #0000ff;">bool</span> cmd;<br />    <span style="color: #0000ff;">int</span> p;<br />    <span style="color: #0000ff;">char</span> ch;<br />    <span style="color: #0000ff;">int</span> pos;<br />} elem[maxn];<br /><br /><span style="color: #0000ff;">struct</span> Node<br />{<br />    Node *pl;<br />    Node *pr;<br />    <span style="color: #0000ff;">int</span> lnum, rnum, l, r;<br />} tree[maxl * <span style="color: #800080;">3</span>];<br /><br /><span style="color: #0000ff;">char</span> st1[maxl], st[maxl];<br /><span style="color: #0000ff;">int</span> n, len, ncount;<br /><br /><span style="color: #0000ff;">void</span> input()<br />{<br />    scanf(<span style="color: #800000;">"</span><span style="color: #800000;">%s%d</span><span style="color: #800000;">"</span>, st1, &amp;n);<br />    len = strlen(st1);<br />    <span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n; i++)<br />    {<br />        <span style="color: #0000ff;">char</span> st[<span style="color: #800080;">5</span>];<br />        scanf(<span style="color: #800000;">"</span><span style="color: #800000;">%s</span><span style="color: #800000;">"</span>, st);<br />        <span style="color: #0000ff;">if</span> (st[<span style="color: #800080;">0</span>] == <span style="color: #800000;">'</span><span style="color: #800000;">I</span><span style="color: #800000;">'</span>)<br />        {<br />            elem[i].cmd = <span style="color: #0000ff;">true</span>;<br />            scanf(<span style="color: #800000;">"</span><span style="color: #800000;">%s%d</span><span style="color: #800000;">"</span>, st, &amp;elem[i].p);<br />            len++;<br />            <span style="color: #0000ff;">if</span> (elem[i].p &gt; len)<br />                elem[i].p = len;<br />            elem[i].ch = st[<span style="color: #800080;">0</span>];<br />        }<br />        <span style="color: #0000ff;">else</span><br />        {<br />            elem[i].cmd = <span style="color: #0000ff;">false</span>;<br />            scanf(<span style="color: #800000;">"</span><span style="color: #800000;">%d</span><span style="color: #800000;">"</span>, &amp;elem[i].p);<br />        }<br />    }<br />}<br /><br /><span style="color: #0000ff;">void</span> build_tree(Node *proot, <span style="color: #0000ff;">int</span> l, <span style="color: #0000ff;">int</span> r)<br />{<br />    <span style="color: #0000ff;">int</span> mid = (l + r) / <span style="color: #800080;">2</span>;<br />    proot-&gt;lnum = mid - l + <span style="color: #800080;">1</span>;<br />    proot-&gt;rnum = r - mid;<br />    proot-&gt;l = l;<br />    proot-&gt;r = r;<br />    <span style="color: #0000ff;">if</span> (l == r)<br />        <span style="color: #0000ff;">return</span>;<br />    ncount++;<br />    proot-&gt;pl = tree + ncount;<br />    ncount++;<br />    proot-&gt;pr = tree + ncount;<br />    build_tree(proot-&gt;pl, l, mid);<br />    build_tree(proot-&gt;pr, mid + <span style="color: #800080;">1</span>, r);<br />}<br /><br /><span style="color: #0000ff;">int</span> query(Node *proot, <span style="color: #0000ff;">int</span> a)<br />{<br />    <span style="color: #0000ff;">if</span> (proot-&gt;l == proot-&gt;r)<br />        <span style="color: #0000ff;">return</span> proot-&gt;l;<br />    <span style="color: #0000ff;">if</span> (a &gt; proot-&gt;lnum)<br />        <span style="color: #0000ff;">return</span> query(proot-&gt;pr, a - proot-&gt;lnum);<br />    <span style="color: #0000ff;">return</span> query(proot-&gt;pl, a);<br />}<br /><br /><span style="color: #0000ff;">void</span> update(Node *proot, <span style="color: #0000ff;">int</span> pos, <span style="color: #0000ff;">int</span> a)<br />{<br />    <span style="color: #0000ff;">if</span> (proot-&gt;l == proot-&gt;r)<br />        <span style="color: #0000ff;">return</span>;<br />    <span style="color: #0000ff;">int</span> mid = (proot-&gt;l + proot-&gt;r) / <span style="color: #800080;">2</span>;<br />    <span style="color: #0000ff;">if</span> (pos &gt; mid)<br />    {<br />        proot-&gt;rnum += a;<br />        update(proot-&gt;pr, pos, a);<br />    }<br />    <span style="color: #0000ff;">else</span><br />    {<br />        proot-&gt;lnum += a;<br />        update(proot-&gt;pl, pos, a);<br />    }<br />}<br /><br /><span style="color: #0000ff;">void</span> work()<br />{<br />    memset(st, <span style="color: #800080;">0</span>, <span style="color: #0000ff;">sizeof</span>(st));<br />    <span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = n - <span style="color: #800080;">1</span>; i &gt;= <span style="color: #800080;">0</span>; i--)<br />        <span style="color: #0000ff;">if</span> (elem[i].cmd)<br />        {<br />            elem[i].pos = query(tree, elem[i].p);<br />            st[elem[i].pos] = elem[i].ch;<br />            update(tree, elem[i].pos, -<span style="color: #800080;">1</span>);<br />        }<br />    <span style="color: #0000ff;">int</span> j = <span style="color: #800080;">0</span>;<br />    <span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">1</span>; i &lt;= len; i++)<br />        <span style="color: #0000ff;">if</span> (!st[i])<br />            st[i] = st1[j++];<br />    <span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n; i++)<br />        <span style="color: #0000ff;">if</span> (elem[i].cmd)<br />            update(tree, elem[i].pos, <span style="color: #800080;">1</span>);<br />        <span style="color: #0000ff;">else</span><br />            printf(<span style="color: #800000;">"</span><span style="color: #800000;">%c\n</span><span style="color: #800000;">"</span>,st[query(tree, elem[i].p)]);<br />}<br /><br /><span style="color: #0000ff;">int</span> main()<br />{<br />    <span style="color: #008000;">//</span><span style="color: #008000;">freopen("t.txt", "r", stdin);</span><span style="color: #008000;"><br /></span>    input();<br />    ncount = <span style="color: #800080;">0</span>;<br />    build_tree(tree, <span style="color: #800080;">1</span>, len);<br />    work();<br />    <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span>;<br />}</pre>
</div>
</div>
<p></p>
