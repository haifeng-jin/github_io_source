---
layout: post
title: poj2054
category: chinese
---
<p>题意：给定一棵树，每个节点有一个权值，现要求给这些节点进行排列，设排列后的节点顺序为v1~vn，它们的权值是w1~wn，那么我们要求一种排列使得w1*1+w2*2+...+wn*n最小。还有一个限制就是这个排列满足每个节点的父节点都排在该结点之前。</p>
<p>分析：试想，如果没有父节点排在节点之前的限制，那么这个题目非常简单，只需要将结点按照权值从大到小排列即可。加上了这个限制之后，如果权值最大的那个节点一旦满足了条件（父节点被排在了之前的某个位置），那么这个权值最大的节点一定要紧挨着这个父节点，即把这个权值最大的节点排在它所能排的最前面的位置。因为对于这个节点如果不受限制应该排在第一位，而有了限制，在满足了限制之后也应把它尽可能地排在前面。所以它一定是挨着父节点的。那么现在在最终的排列中我们确定了两个节点的前后相邻关系，将他们绑定在了一起。</p>
<p>试想如果保持这个相邻关系的同时去掉其他节点的限制，那么我们应该如何排列呢？我们假设绑定在一起的两节点是a和b。现有一个另外的节点x，我们看两种排列xab,abx对最终的计算结果有什么影响。x*i+a*(i+1)+b*(i+2); a*i + b*(i+1) + x*(i+2)。后者减去前者等于2x-(a+b)。即将x从ab之前挪到ab之后，ab各左移1位，结果减小a+b。x右移2位结果增加2x。因此两者谁在前谁在后我们只需要比较a+b和2x即可，也可以比较(a+b)/2和x。</p>
<p>将这个定理进行一下推广，绑定在一起的不一定是两个节点，可以是一个更长的序列，与这个序列进行比较看谁放在前面的也可以是一个序列。设一个序列有n1个节点，第二个序列有n2个节点。那么我们比较两者谁放在前面的时候需要比较的是(n1个权值之和&times;n2)和(n2个权值之和&times;n1)。即左移和右移产生的结果变化。当然也可以比较(n1个权值之和/n1)和(n2个权值之和/n2)。</p>
<p>我们可以再次进行推广，如果我们要排列的不是节点，而是许多序列的话，那么我们只需要计算每个序列权值的平均数（例如：n个节点的序列，要计算n个权值之和/n）,然后按照这个平均数从大到小排列即可使得计算结果最小。这样就可以让序列与节点有了一个统一的衡量值&mdash;&mdash;平均数。</p>
<p>这样一来，我们就可以将上面的绑定两节点的操作看成是将问题规模缩小的操作，在帮定两节点的同时我们在树中也将两节点合并，变为一个节点，即将子节点的孩子变为父节点的孩子。然后合并后的节点的权值是合并在这个节点中的所有节点的权值的平均数。我们成功的将问题规模减小了1。只需要不断这样做即可将问题缩减为只有一个节点。</p>
<p>实现过程中，应在树中每个节点记录并入该节点的个数和权值和。树的存储与绑定前后关系的记录要分开存储，用一个数组单独记录前后绑定的排序关系。</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('9934ba31-53b2-4ab1-bb8f-58aede0e2ad6')"><img id="code_img_closed_9934ba31-53b2-4ab1-bb8f-58aede0e2ad6" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_9934ba31-53b2-4ab1-bb8f-58aede0e2ad6" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('9934ba31-53b2-4ab1-bb8f-58aede0e2ad6',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_9934ba31-53b2-4ab1-bb8f-58aede0e2ad6" class="cnblogs_code_hide">
<pre>#include &lt;cstdio&gt;<span style="color: #000000;">
#include </span>&lt;cstring&gt;
<span style="color: #0000ff;">using</span> <span style="color: #0000ff;">namespace</span><span style="color: #000000;"> std;

</span><span style="color: #0000ff;">#define</span> MAX_NODE_NUM 1005

<span style="color: #0000ff;">struct</span><span style="color: #000000;"> Node
{
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> value;
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> father;
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> next;
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> child;
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> id;
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> num;
}node[MAX_NODE_NUM];

</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> root_id, node_num;
</span><span style="color: #0000ff;">bool</span><span style="color: #000000;"> vis[MAX_NODE_NUM];
</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> link[MAX_NODE_NUM];
</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> original_value[MAX_NODE_NUM];

</span><span style="color: #0000ff;">void</span> add_edge(<span style="color: #0000ff;">int</span> father, <span style="color: #0000ff;">int</span><span style="color: #000000;"> son)
{
    </span><span style="color: #0000ff;">int</span> temp =<span style="color: #000000;"> node[father].child;
    node[father].child </span>=<span style="color: #000000;"> son;
    node[son].next </span>=<span style="color: #000000;"> temp;
    node[son].father </span>=<span style="color: #000000;"> father;
}

</span><span style="color: #0000ff;">void</span><span style="color: #000000;"> input()
{
    memset(node, </span>-<span style="color: #800080;">1</span>, <span style="color: #0000ff;">sizeof</span><span style="color: #000000;">(node));
    </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; node_num; i++<span style="color: #000000;">)
    {
        scanf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d</span><span style="color: #800000;">"</span>, &amp;<span style="color: #000000;">node[i].value);
        node[i].id </span>=<span style="color: #000000;"> i;
        node[i].num </span>= <span style="color: #800080;">1</span><span style="color: #000000;">;
        original_value[i] </span>=<span style="color: #000000;"> node[i].value;
    }
    </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; node_num - <span style="color: #800080;">1</span>; i++<span style="color: #000000;">)
    {
        </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> node_a, node_b;
        scanf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d%d</span><span style="color: #800000;">"</span>, &amp;node_a, &amp;<span style="color: #000000;">node_b);
        node_a</span>--<span style="color: #000000;">;
        node_b</span>--<span style="color: #000000;">;
        add_edge(node_a, node_b);
    }
}

</span><span style="color: #0000ff;">void</span> merge_with_father(<span style="color: #0000ff;">int</span><span style="color: #000000;"> id)
{
    </span><span style="color: #0000ff;">int</span> father =<span style="color: #000000;"> node[id].father;
    node[father].value </span>+=<span style="color: #000000;"> node[id].value;
    node[father].num </span>+=<span style="color: #000000;"> node[id].num;
    node[father].id </span>=<span style="color: #000000;"> node[id].id;
    </span><span style="color: #0000ff;">int</span> end =<span style="color: #000000;"> id;
    </span><span style="color: #0000ff;">while</span> (node[end].next != -<span style="color: #800080;">1</span><span style="color: #000000;">)
        end </span>=<span style="color: #000000;"> node[end].next;
    node[end].next </span>=<span style="color: #000000;"> node[id].child;
    </span><span style="color: #0000ff;">while</span> (node[end].next != -<span style="color: #800080;">1</span><span style="color: #000000;">)
    {
        end </span>=<span style="color: #000000;"> node[end].next;
        node[end].father </span>=<span style="color: #000000;"> father;
    }
    </span><span style="color: #008000;">//</span><span style="color: #008000;">printf("father:%d\tson:%d\n", father + 1, id + 1);</span>
<span style="color: #000000;">}

</span><span style="color: #0000ff;">bool</span> larger(<span style="color: #0000ff;">int</span> a, <span style="color: #0000ff;">int</span><span style="color: #000000;"> b)
{
    </span><span style="color: #0000ff;">if</span> (a == -<span style="color: #800080;">1</span><span style="color: #000000;">)
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">return</span> node[a].value * node[b].num &lt; node[b].value *<span style="color: #000000;"> node[a].num;
}

</span><span style="color: #0000ff;">void</span><span style="color: #000000;"> work()
{
    memset(vis, </span><span style="color: #800080;">0</span>, <span style="color: #0000ff;">sizeof</span><span style="color: #000000;">(vis));
    vis[root_id] </span>= <span style="color: #0000ff;">true</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">while</span> (<span style="color: #800080;">1</span><span style="color: #000000;">)
    {
        </span><span style="color: #0000ff;">int</span> p = -<span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; node_num; i++<span style="color: #000000;">)
            </span><span style="color: #0000ff;">if</span> (!vis[i] &amp;&amp;<span style="color: #000000;"> larger(p, i))
                p </span>=<span style="color: #000000;"> i;
        </span><span style="color: #0000ff;">if</span> (p == -<span style="color: #800080;">1</span><span style="color: #000000;">)
            </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
        vis[p] </span>= <span style="color: #0000ff;">true</span><span style="color: #000000;">;
        link[node[node[p].father].id] </span>=<span style="color: #000000;"> p;
    </span><span style="color: #008000;">//</span><span style="color: #008000;">    printf("a:%d\tb:%d\n", node[node[p].father].id + 1, p + 1);</span>
<span style="color: #000000;">        merge_with_father(p);
    }
    </span><span style="color: #0000ff;">int</span> temp =<span style="color: #000000;"> root_id;
    </span><span style="color: #0000ff;">int</span> ans = <span style="color: #800080;">0</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">1</span>; i &lt;= node_num; i++<span style="color: #000000;">)
    {
    </span><span style="color: #008000;">//</span><span style="color: #008000;">    printf("%d ", temp + 1);</span>
        ans += i *<span style="color: #000000;"> original_value[temp];
        temp </span>=<span style="color: #000000;"> link[temp];    
    }
    printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d\n</span><span style="color: #800000;">"</span><span style="color: #000000;">, ans);
}

</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> main()
{
    </span><span style="color: #0000ff;">while</span> (scanf(<span style="color: #800000;">"</span><span style="color: #800000;">%d%d</span><span style="color: #800000;">"</span>, &amp;node_num, &amp;root_id), node_num |<span style="color: #000000;"> root_id)
    {
        root_id</span>--<span style="color: #000000;">;
        input();
        work();
    }
    </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
}</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code </span></div>
<p>&nbsp;</p>
