---
layout: post
title: poj2253
category: chinese
---
<p>dijkstra</p>  <p>把存最短距离的数组改为存储frog distance即可</p>  <p>&#160;</p>  <pre class="brush: cpp; auto-links: true; collapse: true; first-line: 1; gutter: true; html-script: false; light: false; ruler: false; smart-tabs: true; tab-size: 4; toolbar: true;">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;cstdlib&gt;
#include &lt;cmath&gt;
using namespace std;

const int maxn = 201, inf = 1000000000;

struct point
{
	int x, y;
} stone[maxn];

int n;
double dist[maxn];
bool vis[maxn];

void init()
{
	for (int i = 0; i &lt; n; i++)
		scanf(&quot;%d%d&quot;, &amp;stone[i].x, &amp;stone[i].y);
}

double distan(point &amp;a, point &amp;b)
{
	return sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));
}

void dijkstra()
{
	double best = 0;
	int besti = 0;

	for (int i = 0; i &lt; n; i++)
		dist[i] = inf;
	memset(vis, 0, sizeof(vis));
	vis[0] = true;
	dist[0] = 0;
	while (besti != -1 &amp;&amp; !vis[1])
	{
		for (int i = 0; i &lt; n; i++)
		{
			double temp = max(dist[besti], distan(stone[i], stone[besti]));
			if (dist[i] &gt; temp)
				dist[i] = temp;
		}
		best = inf;
		besti = -1;
		for (int i = 0; i &lt; n; i++)
			if (!vis[i] &amp;&amp; dist[i] &lt; best)
			{
				best = dist[i];
				besti = i;
			}
		vis[besti] = true;
	}
}

int main()
{
	//freopen(&quot;D:\\t.txt&quot;, &quot;r&quot;, stdin);
	int t = 0;
	while (scanf(&quot;%d&quot;, &amp;n) != EOF &amp;&amp; n != 0)
	{
		init();
		dijkstra();
		t++;
		printf(&quot;Scenario #%d\nFrog Distance = %.3f\n\n&quot;, t, dist[1]);
	}
	return 0;
}</pre>
