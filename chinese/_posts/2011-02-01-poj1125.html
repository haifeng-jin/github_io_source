---
layout: post
title: poj1125
category: chinese
---
<p>floyd算法，floyd过后查看每个点传播消息需要的时间，把最小的点输出即可。</p>  <p>&#160;</p>  <pre class="brush: cpp; auto-links: true; collapse: true; first-line: 1; gutter: true; html-script: false; light: false; ruler: false; smart-tabs: true; tab-size: 4; toolbar: true;">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;cstdlib&gt;
using namespace std;

const int maxn = 101;

int dist[maxn][maxn];
int n;

void init()
{
	memset(dist, -1, sizeof(dist));
	for (int i = 0; i &lt; n; i++)
	{
		int m;
		scanf(&quot;%d&quot;, &amp;m);
		for (int j = 0; j &lt; m; j++)
		{
			int a, b;
			scanf(&quot;%d%d&quot;, &amp;a, &amp;b);
			a--;
			dist[i][a] = b;
		}
	}
}

void floyd()
{
	for (int i = 0; i &lt; n; i++)
		for (int j = 0; j &lt; n; j++)
			if (dist[j][i] != -1)
				for (int k = 0; k &lt; n; k++)
					if (dist[i][k] != -1)
						if (dist[j][k] == -1 || dist[j][k] &gt; dist[j][i] + dist[i][k])
							dist[j][k] = dist[j][i] + dist[i][k];
}

void work()
{
	int ans = 1000000000, ansi = -1;

	for (int i = 0; i &lt; n; i++)
	{
		bool ok = true;
		int maxdist = 0;
		for (int j = 0; j &lt; n; j++)
		{
			if (i == j)
				continue;
			if (dist[i][j] == -1)
			{
				ok = false;
				break;
			}
			if (maxdist &lt; dist[i][j])
				maxdist = dist[i][j];
		}
		if (maxdist &lt; ans &amp;&amp; ok)
		{
			ans = maxdist;
			ansi = i;
		}
	}
	if (ansi == -1)
		printf(&quot;disjoint\n&quot;);
	else
		printf(&quot;%d %d\n&quot;, ansi + 1, ans);
}

int main()
{
	//freopen(&quot;D:\\t.txt&quot;, &quot;r&quot;, stdin);
	while (scanf(&quot;%d&quot;, &amp;n) != EOF &amp;&amp; n != 0)
	{
		init();
		floyd();
		work();
	}
	return 0;
}</pre>
