---
layout: post
title: poj1328
category: chinese
---
<p>题意：平面上有一些点，现要求用一些圆心在x轴上的圆（雷达）来覆盖这些点，问最少需要多少雷达。</p>
<p><span style="color: #000000;"><span style="font-family: verdana, Arial, Helvetica, sans-serif;"><span style="font-size: small;">分析：</span></span></span>我的解法是把点按横坐标排序，然后把每个点的雷达尽量往右放，然后每放一个雷达都要保证雷达左面的岛都被雷达所覆盖。所以我们可以按一个点靠右放完雷达后，再根据后面的在雷达位置左面的点，把雷达向左移。一个雷达经过了移的过程，就一定是能覆盖左面的岛。所以排好序后，只需O(n)。</p>
<p>注意：unique函数的返回值是结尾指针，所以可以用被注释掉两行的方法来获得数组长度。</p>
<p>标准方法是把每个点的放置雷达的区间求出，然后按照区间排序。排好序后，从左至右看，当发现下一个区间的起始点大于前面所有区间的最小结束点的时候，答案加一。忽视前面走过的所有点后，对后面进行相同的操作（从左至右看，当发现下一个区间的起始点大于左边未被忽视的所有区间的最小结束点的时候，答案加一）。直到结束。</p>
<p>&nbsp;</p>
<pre class="brush: cpp; auto-links: true; collapse: true; first-line: 1; gutter: true; html-script: false; light: false; ruler: false; smart-tabs: true; tab-size: 4; toolbar: true;">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;cstdlib&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;
using namespace std;

const int maxn = 1001;

struct Point
{
	int x, y;
} point[maxn];

int n, d, ans;
bool ok;

bool operator &lt; (const Point &amp;a, const Point &amp;b)
{
	return a.x &lt; b.x;
}

bool operator == (const Point &amp;a, const Point &amp;b)
{
	return ((a.x == b.x) &amp;&amp; (a.y == b.y));
}

void init()
{
	int i;

	ok = true;
	for (i = 0; i &lt; n; i++)
	{
		scanf("%d%d", &amp;point[i].x, &amp;point[i].y);
		if (point[i].y &gt; d)
			ok = false;
	}
}

double getx(Point &amp;a)
{
	return a.x + sqrt(double(d * d - a.y * a.y));
}

void work()
{
	int	i;
	double x=getx(point[0]);

	ans = 1;
	for (i = 1; i &lt; n; i++)
	{
		double	temp = getx(point[i]);
		if (point[i].x &lt; x &amp;&amp; x &gt; temp)
		{
			x = temp;
			continue;
		}
		if (point[i].y * point[i].y + (point[i].x - x) * (point[i].x - x) &lt;= d * d)
			continue;
		x = getx(point[i]);
		ans++;
	}
}

int main()
{
	int	casenum = 0;

	//freopen("D:\\t.txt", "r", stdin);
	while (cin &gt;&gt; n &gt;&gt; d &amp;&amp; !(n == 0 &amp;&amp; d == 0))
	{
		casenum++;
		init();
		if (!ok)
		{
			printf("Case %d: -1\n", casenum);
			continue;
		}
		sort(point, point + n);
//		Point *p = unique(point, point + n);
//		n = (p - point);
		work();
		printf("Case %d: %d\n", casenum, ans);
	}
	return 0;
}</pre>
