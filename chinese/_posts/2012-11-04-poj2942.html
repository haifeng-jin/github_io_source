---
layout: post
title: poj2942
category: chinese
---
<p>題意：一些骑士，他们有些人之间有矛盾，现在要求选出一些骑士围成一圈，圈要满足如下条件：1.人数大于1。2.总人数为奇数。3.有仇恨的骑士不能挨着坐。问有几个骑士不能和任何人形成任何的圆圈。</p>
<p>分析：双连通分支。</p>
<p>建图方法是将没有矛盾的骑士连边，求双连通分量（关于点的）。对于每个双连通分量，看是否存在奇环，若存在那么这个双连通分量中的任意两骑士都可以同时出现在一个奇环里。原因如下：</p>
<p>因为每个不在那个奇环里的点都一定能找到两条连到奇环上不同节点的路径，然后奇环被分割为一个总数为奇数的节点串和一个总数为偶数的节点串，这时做出正确的选出和那一串构成环即可形成奇环。</p>
<p>那么如何判断一个双连通分量是否存在奇环呢？</p>
<p>用交叉染色法判断是不是二分图，一个图是二分图是不存在奇环的充要条件。注意，交叉染色法可以用dfs实现也可以用bfs实现。</p>
<p>还要注意由于有些顶点同时属于多个双连通分量，计算这些顶点是否是答案的时候不要算重复了。</p>
<p><span style="color: #ff0000;">重点说一下求点双连通分支的方法，我网上查到的所有版本对这个算法的描述都是错的。</span></p>
<p>首先，用tarjan算法，dfs遍历全图，用dfs_dep数组记录每个点在遍历过程中的深度，用low_point数组记录每个点的邻居中（不包括父亲）深度最浅的节点，把遍历过程中所有树枝边入栈。我们在遍历过程中，对于一个节点u，如果在遍历完成它的某子节点v之后，发现low_point[v]==dfs_dep[u]则说明u与v及其子孙构成一个点双连通分量，我们不停弹栈直到边(u,v)被弹出，和这些边相关的点构成一个点双连通分量。当我们遍历完点u的所有子孙之后，若发现low_point[u]==dfs_dep[u]，则说明u不会再与其祖宗节点构成点双连通分量，但此时还有一条u的父亲和u的连边存在于栈顶，我们要把它弹出并丢弃。</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('878686c3-a5cf-423f-9af4-14d506a36c70')"><img id="code_img_closed_878686c3-a5cf-423f-9af4-14d506a36c70" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_878686c3-a5cf-423f-9af4-14d506a36c70" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('878686c3-a5cf-423f-9af4-14d506a36c70',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" /><span class="cnblogs_code_collapse">View Code </span>
<div id="cnblogs_code_open_878686c3-a5cf-423f-9af4-14d506a36c70" class="cnblogs_code_hide">
<pre>#include &lt;iostream&gt;<span style="color: #000000;">
#include </span>&lt;cstdio&gt;<span style="color: #000000;">
#include </span>&lt;cstring&gt;<span style="color: #000000;">
#include </span>&lt;cstdlib&gt;<span style="color: #000000;">
#include </span>&lt;algorithm&gt;
<span style="color: #0000ff;">using</span> <span style="color: #0000ff;">namespace</span><span style="color: #000000;"> std;

</span><span style="color: #0000ff;">#define</span> maxn 1005
<span style="color: #0000ff;">#define</span> maxm 1000005

<span style="color: #0000ff;">struct</span><span style="color: #000000;"> Edge
{
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> v, next;
} edge[maxm </span>* <span style="color: #800080;">2</span><span style="color: #000000;">];

</span><span style="color: #0000ff;">struct</span><span style="color: #000000;"> Elem
{
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> u, v;
    Elem()
    {
    }
    Elem(</span><span style="color: #0000ff;">int</span> uu, <span style="color: #0000ff;">int</span><span style="color: #000000;"> vv) :
            u(uu), v(vv)
    {
    }
} stk[maxm </span>* <span style="color: #800080;">2</span><span style="color: #000000;">];

</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> head[maxn];
</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> cnt;
</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> dfs_dep[maxn];
</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> low_point[maxn];
</span><span style="color: #0000ff;">bool</span><span style="color: #000000;"> vis[maxn];
</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> top;
</span><span style="color: #0000ff;">bool</span><span style="color: #000000;"> is_cut_vertex[maxn];
</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> n, m;
</span><span style="color: #0000ff;">bool</span><span style="color: #000000;"> is_current_component[maxn];
</span><span style="color: #0000ff;">bool</span><span style="color: #000000;"> counted[maxn];
</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> ans;

</span><span style="color: #0000ff;">void</span> addedge(<span style="color: #0000ff;">int</span> a, <span style="color: #0000ff;">int</span><span style="color: #000000;"> b)
{
    edge[cnt].v </span>=<span style="color: #000000;"> b;
    edge[cnt].next </span>=<span style="color: #000000;"> head[a];
    head[a] </span>= cnt++<span style="color: #000000;">;
}

</span><span style="color: #0000ff;">void</span><span style="color: #000000;"> init()
{
    memset(is_current_component, </span><span style="color: #800080;">0</span>, <span style="color: #0000ff;">sizeof</span><span style="color: #000000;">(is_current_component));
}

</span><span style="color: #0000ff;">void</span> add(Elem &amp;<span style="color: #000000;">a)
{
    is_current_component[a.u] </span>= <span style="color: #0000ff;">true</span><span style="color: #000000;">;
    is_current_component[a.v] </span>= <span style="color: #0000ff;">true</span><span style="color: #000000;">;
}

</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> color[maxn];
</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> q[maxn];

</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> count_it()
{
    </span><span style="color: #0000ff;">int</span> ret = <span style="color: #800080;">0</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n; i++<span style="color: #000000;">)
        </span><span style="color: #0000ff;">if</span> (is_current_component[i] &amp;&amp; !<span style="color: #000000;">counted[i])
        {
            counted[i] </span>= <span style="color: #0000ff;">true</span><span style="color: #000000;">;
            ret</span>++<span style="color: #000000;">;
        }
    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> ret;
}

</span><span style="color: #0000ff;">int</span> judge(<span style="color: #0000ff;">int</span><span style="color: #000000;"> a)
{
    </span><span style="color: #0000ff;">int</span> front = <span style="color: #800080;">0</span>, rear = <span style="color: #800080;">0</span><span style="color: #000000;">;
    memset(color, </span>-<span style="color: #800080;">1</span>, <span style="color: #0000ff;">sizeof</span><span style="color: #000000;">(color));
    q[rear</span>++] =<span style="color: #000000;"> a;
    color[a] </span>= <span style="color: #800080;">0</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">while</span> (front !=<span style="color: #000000;"> rear)
    {
        </span><span style="color: #0000ff;">int</span> u = q[front++<span style="color: #000000;">];
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = head[u]; ~i; i =<span style="color: #000000;"> edge[i].next)
        {
            </span><span style="color: #0000ff;">int</span> v =<span style="color: #000000;"> edge[i].v;
            </span><span style="color: #0000ff;">if</span> (!<span style="color: #000000;">is_current_component[v])
                </span><span style="color: #0000ff;">continue</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">if</span> (~color[v] &amp;&amp; color[v] ==<span style="color: #000000;"> color[u])
                </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> count_it();
            </span><span style="color: #0000ff;">if</span> (color[v] == -<span style="color: #800080;">1</span><span style="color: #000000;">)
            {
                q[rear</span>++] =<span style="color: #000000;"> v;
                color[v] </span>= (color[u] ^ <span style="color: #800080;">1</span><span style="color: #000000;">);
            }
        }
    }
    </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
}

</span><span style="color: #0000ff;">void</span> tarjan(<span style="color: #0000ff;">int</span> dep, <span style="color: #0000ff;">int</span> parent, <span style="color: #0000ff;">int</span><span style="color: #000000;"> u)
{
    </span><span style="color: #0000ff;">int</span> descendant = <span style="color: #800080;">0</span><span style="color: #000000;">;
    dfs_dep[u] </span>= low_point[u] =<span style="color: #000000;"> dep;
    vis[u] </span>= <span style="color: #0000ff;">true</span><span style="color: #000000;">;
    stk[top</span>++] =<span style="color: #000000;"> Elem(parent, u);
    </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = head[u]; ~i; i =<span style="color: #000000;"> edge[i].next)
    {
        </span><span style="color: #0000ff;">int</span> v =<span style="color: #000000;"> edge[i].v;
        </span><span style="color: #0000ff;">if</span> (v ==<span style="color: #000000;"> parent)
            </span><span style="color: #0000ff;">continue</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (vis[v])
        {
            low_point[u] </span>=<span style="color: #000000;"> min(low_point[u], dfs_dep[v]);
            </span><span style="color: #0000ff;">continue</span><span style="color: #000000;">;
        }
        tarjan(dep </span>+ <span style="color: #800080;">1</span><span style="color: #000000;">, u, v);
        low_point[u] </span>=<span style="color: #000000;"> min(low_point[u], low_point[v]);
        </span><span style="color: #0000ff;">if</span> (low_point[v] &gt;=<span style="color: #000000;"> dep)
            descendant</span>++<span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span> (low_point[v] ==<span style="color: #000000;"> dep)
        {
            init();
            </span><span style="color: #0000ff;">while</span> (!(stk[top].u == u &amp;&amp; stk[top].v ==<span style="color: #000000;"> v))
                add(stk[</span>--<span style="color: #000000;">top]);
            ans </span>+=<span style="color: #000000;"> judge(v);
        }
    }
    </span><span style="color: #0000ff;">if</span> (low_point[u] ==<span style="color: #000000;"> dep)
        top</span>--<span style="color: #000000;">;
    </span><span style="color: #0000ff;">if</span> (parent == -<span style="color: #800080;">1</span><span style="color: #000000;">)
        descendant</span>--<span style="color: #000000;">;
    </span><span style="color: #0000ff;">if</span> (descendant &gt; <span style="color: #800080;">0</span><span style="color: #000000;">)
        is_cut_vertex[u] </span>= <span style="color: #0000ff;">true</span><span style="color: #000000;">;
}

</span><span style="color: #0000ff;">bool</span><span style="color: #000000;"> g[maxn][maxn];

</span><span style="color: #0000ff;">void</span><span style="color: #000000;"> input()
{
    memset(g, </span><span style="color: #800080;">0</span>, <span style="color: #0000ff;">sizeof</span><span style="color: #000000;">(g));
    </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; m; i++<span style="color: #000000;">)
    {
        </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> a, b;
        scanf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d%d</span><span style="color: #800000;">"</span>, &amp;a, &amp;<span style="color: #000000;">b);
        a</span>--<span style="color: #000000;">;
        b</span>--<span style="color: #000000;">;
        g[a][b] </span>= g[b][a] = <span style="color: #0000ff;">true</span><span style="color: #000000;">;
    }
    </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n; i++<span style="color: #000000;">)
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">0</span>; j &lt; n; j++<span style="color: #000000;">)
            </span><span style="color: #0000ff;">if</span> (i != j &amp;&amp; !<span style="color: #000000;">g[i][j])
                addedge(i, j);
}

</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> main()
{
    </span><span style="color: #008000;">//</span><span style="color: #008000;">freopen("t.txt", "r", stdin);</span>
    <span style="color: #0000ff;">while</span> (scanf(<span style="color: #800000;">"</span><span style="color: #800000;">%d%d</span><span style="color: #800000;">"</span>, &amp;n, &amp;m), n |<span style="color: #000000;"> m)
    {
        memset(head, </span>-<span style="color: #800080;">1</span>, <span style="color: #0000ff;">sizeof</span><span style="color: #000000;">(head));
        memset(vis, </span><span style="color: #800080;">0</span>, <span style="color: #0000ff;">sizeof</span><span style="color: #000000;">(vis));
        memset(counted, </span><span style="color: #800080;">0</span>, <span style="color: #0000ff;">sizeof</span><span style="color: #000000;">(counted));
        cnt </span>= <span style="color: #800080;">0</span><span style="color: #000000;">;
        input();
        ans </span>= <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n; i++<span style="color: #000000;">)
            </span><span style="color: #0000ff;">if</span> (!<span style="color: #000000;">vis[i])
                tarjan(</span><span style="color: #800080;">0</span>, -<span style="color: #800080;">1</span><span style="color: #000000;">, i);
        printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d\n</span><span style="color: #800000;">"</span>, n -<span style="color: #000000;"> ans);
    }
    </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
}</span></pre>
</div>
</div>
